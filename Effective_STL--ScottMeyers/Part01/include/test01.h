
using namespace std;

// 第13条 vector 和 string 优先于动态分配的数组
/*
* 如果使用 new 来动态分配内存时，必须注意
* a.确保使用 delete 来删除所分配的内存，如果没有 delete 则会导致内存泄露
* b.必须确保使用了正确的 delete 形式
*	如果分配了单个对象，必须使用 delete
*	如果分配了数组，必须使用 delete[]
* c.必须确保只 delete 了一次，如果一次分配被多次 delete ，结果同样是 不确定的
*/

// 许多 string 实现在背后使用了 引用计数技术，这种策略可以消除不必要的内存分配和不必要的字符拷贝，从而可以提高很多应用程序的效率
// 如果你在多线程环境中使用了引用计数的 string ，会发现，由避免内存分配和字符拷贝所省下来的时间还比不上花在背后同步控制上的时间
// 如果在多线程环境中使用了 引用计数的 strig ,注意一下因支持线程安全而导致的性能问题是很有意义的
// 可以考虑 vector<char> 而不是 string 。

// 第14条 使用 reserve 来避免不必要的重新分配
// 最大限制，调用适当的名为 max_size 的成员函数
// 对于 vector 和 string ，增长过程是这样来实现的
// 每当需要更多空间时，就调用与 realloc 类似的操作
//	1.分配一块大小为当前容量的某个倍数的新内存，大多数实现中，vector 和 string 的容量每次以 2 的倍数增长，即每当容器需要扩容时，容量加倍
//	2.把容器的所有元素从旧的内存复制到新的内存中
//	3.析构掉旧内存中的对象
//	4.释放旧内存
//	而且 每当这些步骤发生时，vector 或 string 中所有的指针、迭代器和引用都将变得无效，有必要避免这些步骤
// reserve 成员函数能使重新分配的次数减少到最低限度，从而避免 重新分配和指针/迭代器/引用失效带来的开销
// 



class Test01
{
public:
	Test01() {};
	~Test01() {};

	void Demo_01_();

};
