
using namespace std;

// 第13条 vector 和 string 优先于动态分配的数组
/*
* 如果使用 new 来动态分配内存时，必须注意
* a.确保使用 delete 来删除所分配的内存，如果没有 delete 则会导致内存泄露
* b.必须确保使用了正确的 delete 形式
*	如果分配了单个对象，必须使用 delete
*	如果分配了数组，必须使用 delete[]
* c.必须确保只 delete 了一次，如果一次分配被多次 delete ，结果同样是 不确定的
*/

// 许多 string 实现在背后使用了 引用计数技术，这种策略可以消除不必要的内存分配和不必要的字符拷贝，从而可以提高很多应用程序的效率
// 如果你在多线程环境中使用了引用计数的 string ，会发现，由避免内存分配和字符拷贝所省下来的时间还比不上花在背后同步控制上的时间
// 如果在多线程环境中使用了 引用计数的 strig ,注意一下因支持线程安全而导致的性能问题是很有意义的
// 可以考虑 vector<char> 而不是 string 。

// 第14条 使用 reserve 来避免不必要的重新分配
// 最大限制，调用适当的名为 max_size 的成员函数
// 对于 vector 和 string ，增长过程是这样来实现的
// 每当需要更多空间时，就调用与 realloc 类似的操作
//	1.分配一块大小为当前容量的某个倍数的新内存，大多数实现中，vector 和 string 的容量每次以 2 的倍数增长，即每当容器需要扩容时，容量加倍
//	2.把容器的所有元素从旧的内存复制到新的内存中
//	3.析构掉旧内存中的对象
//	4.释放旧内存
//	而且 每当这些步骤发生时，vector 或 string 中所有的指针、迭代器和引用都将变得无效，有必要避免这些步骤
// reserve 成员函数能使重新分配的次数减少到最低限度，从而避免 重新分配和指针/迭代器/引用失效带来的开销
// 
// size() 告诉你该容器中有多少个元素，不会告诉你该容器为自己所包含的元素分配了多少内存
// capacity() 是容器所能容纳的元素总数，而不是还能容纳多少个元素。可以用 capacity() 减去 size() 知道还有多少未被使用的内存。如果为 0 ，则下一个插入操作将导致上面讲过的重新分配过程
// resize() 强迫容器改变到包含 n 个元素的状态
// 如果 n 比当前的大小要小，则容器的尾部的元素将会被析构
// 如果 n 比当前的大小要大，则通过默认构造函数创建的新元素将被添加到容器的末尾。并且添加元素之前，重新分配内存
// reserve() 强迫容器把容量变为至少是 n ，前提是 n 不小于当前的大小。
// 通常会导致重新分配，因为容量需要增加(如果 n 比当前的容量小，则 vector 忽略该调用，string 则可能把自己的容量减为 size() 和 n 中的最大值，但是 string 的大小肯定保持不变。
// 作者推荐，使用 reserve 从 string 中除去多余的容量通常不如 使用 "swap技巧"

// 通过两种方式来使用 reserve 以避免不必要的重新分配
// 1.能确切知道或大致预计容器中最终会有多少元素，则可使用 reserve
// 2.预留足够大的空间，然后把所有数据加入以后，再出去多余的容量
//  去除多余容量技巧
//  

// 第15条 注意 string 实现的多样性

class Test01
{
public:
	Test01() {};
	~Test01() {};

	void Demo_01_reserve();

};
