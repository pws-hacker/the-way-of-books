using namespace std;

// 建议52 理解数组的存储实质
// 建议52-1 理解数组的存储布局
// 建议52-2 理解 &a[0] (数组首元素的首地址) 和&a的区别
// 建议52-3 理解数组名a作为右值和左值的区别
// 当数组名 a 作为左值的适合，代表的同样时数组的首元素的首地址。但是这个地址开始的一块内存是一个总体(即数组一旦定义就会被分配一片连续的存储空间)
// 我们只能访问数组的某个元素，无法把数组当一个总体进行访问，也就是可以将a[0]作为左值，无法将 a 作为左值

// 建议53 避免数组越界
// 数组越界就是指数组下标变量的取值超过了初始定义时的大小，导致对数组元素的访问出现在数组的范围之外
// C 语言并不检验数组便捷，数组的两端都有可能越界，从而使其他变量的数据甚至程序代码被破坏，检验数组的边界是程序员的职责
// 1.数组下标取值越界
// 2.指向数组的指针的指向范围越界指定义数组时返回一个指向第一个变量的头指针，对这个指针进行加减运算可以向前或向后移动这个指针，进而访问数组中所有的变量

// 建议53-1 尽量显式地指定数组的边界
// 建议53-2 对数组做越界检查，确保索引值位于合法的范围之内
// 建议53-3	获取数组的长度时不对指针应用 sizeof 操作符
// sizeof 不能用于函数类型、不完全类型(指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知的结构或联合类型、void类型等)与位字段

// 建议54 数组并非指针
// 编译器为每个变量分配一个地址(左值) ，这个地址在编译时可知，而且该变量在运行时一直保存于这个地址。
// 存储于变量中的值(右值) 只有在运行时才知。如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它存于寄存器中。

class Advise53
{
public:
	Advise53() {};
	~Advise53() {};

	void test_01_error(void);
	void test_02_demo();

	int* test_03_error_demo(int num,int value);
	int* test_03_right_demo(size_t num,int value);

	void test_04_error(void);
	void test_04_right1(void);
	void test_04_right2(void);

	void test_05_demo(void);  // 数组和指针的区别
};

// 建议55 理解数组与指针的可交换性
// 1."表达式中的数组名" 就是指针
// 表达式中的数组名 (数组在使用中，而不是声明中) 被编译器当作一个指向该数组第一个元素的指针
// 2.数组下标就是指针的偏移量
// 3.函数形参中的数组名被当作指向第一个元素的指针
// 所有数组在作为 参数传递 时，都转换为指向数组起始地址的指针，而其他参数均采用传值调用

// 建议56 禁止将一个指向非数组对象的指针加上或减去一个整数
// 当对指针进行算法运算时(算数运算只限于指针加上或减去某个整数),必须是指向数组对象的元素

// 建议57 禁止对两个并不指向同一个数组的指针进行相减或比较
// 如果两个指针指向同一个数组，它们就可以相减，其结果为两个指针之间的元素数目(而不是字节数目)
// 可以利用两个指向同一数组的指针相减得到两个指针之间元素的个数
// 如果两个指针不是指向同一个数组，它们的结果是未定义的。

// 建议58 若结果值并不引用合法的数组元素，不要将指针加上或减去一个整数
// 如果一个指针加上或减去一个整数后，其结果将不再指向数组中的元素，又或者是数组最后一个元素之后的那个未知，其行为是未定义的。还有可能导致缓冲区溢出

class Advise56
{
public:
	Advise56() {};
	~Advise56() {};
	
	void test_01_demo(void);
	void test_02_error(void);
};