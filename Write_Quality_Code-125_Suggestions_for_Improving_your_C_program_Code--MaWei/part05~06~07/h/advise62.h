

using namespace std;

// 建议62 结构体的设计要遵循简单、单一原则
// 结构体变量的定义方式
// 1.先定义结构体类型，再定义结构体变量
struct Date
{
	int year;
	int month;
	int day;
};
struct Date today;
// 2.在定义结构体类型的同时定义结构体变量
struct Date1 
{
	int year;
	int month;
	int day;
}today1;
// 3.直接定义结构体变量
struct
{
	int year;
	int month;
	int day;
}today2;
// 一般会使用 typedef 关键字为结构体类型定义一个别名
typedef struct Node
{
	void* data;
	int dataLength;
	struct node* next;
};

// 建议62-1 尽量使结构体的功能单一
// 在设计结构体时应力争使结果提只代表一种现实事务的抽象，而不是同时代表多种。
// 结构体中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构体中
// 建议62-2 尽量减少结构体间关系的复杂度
// 建议62-3 尽量使结构体中元素的个数适中
// 如果结构体中元素个数过多，可考虑依据某种原则把元素组成不同的子结构体，以减少原结构体中元素的个数，从而增加结构体的可理解性、可操作性和可维护性
// 建议62-4 合理划分与改进结构体以提高空间效率

// 建议63 合理利用结构体内存对其原理来提高程序效率
// 内存对齐作为一种强制要求，一方面简化了处理器与内存之间传输系统的设计，另一方面可以提升读取数据的速度，内存对齐是一种"以空间换时间"的策略
// 结构体大小的计算方法
// 1.将结构体内所有数据成员的长度值相加，记为 sum_a
// 2.将各数据成员内存对齐，按各自对齐模数而填充的字节数累加到 和sum_a 上，记为 sum_b
//		对齐模数是 #pragma pack 指定的数值及该数据成员自身长度中数值较小者。该数据 相对起始位置 是对齐模数的整数倍
//		offsetof 宏的作用是计算结构体中每一个成员的偏移量，用 offsetof 宏可以清晰看到字节是如何对齐的
//		第一个成员的 offsetof 为 0; 以后的成员 是否偏移，应该计算该成员的起始位置是否是对齐模数的整数倍，不是则填充字节
// 3.将 和sum_b 向结构体模数对齐，该模数是 #pragma pack 指定的数值和结构体内部最大的基本数据类型长度中数值较小者，结构体的长度应该是该模数的整数倍
// 4.结构体嵌套结构体，可以就地把结构体中嵌套的那个结构体就地展开进行计算

// vs 的默认对齐模数 #pragma pack(n) : n = 8
// 改变默认对齐模数
// 1. 使用 伪指令 #pragma pack(n) 可以改变默认的对齐模数 ,n 表示对齐模数，可以是 1，2，4，8等
// 2. 使用 伪指令 #pragma pack()  取消自定义字节对齐方式，即将上一次 #pragma pack(n) 的设置取消，恢复默认值

// 建议64 结构体的长度不一定等于各个成员之和  因为 内存对齐
// 建议65 避免在结构体之间 逐字节 比较  因为 内存对齐

// 建议66 谨慎使用位域


class Advise62
{
public:
	Advise62() {};
	~Advise62() {};



};