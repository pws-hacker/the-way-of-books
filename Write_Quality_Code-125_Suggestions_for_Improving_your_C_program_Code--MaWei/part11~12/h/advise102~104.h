

using namespace std;

// 建议102 浅谈程序的内存结构
/*
* 五种不同的数据区域
* 1.存储时的区域
*	a.未初始化数据段
*	b.已初始化数据段
*	c.代码段

* 2.运行时的区域
*	a.栈(stack)
*	b.堆(heap)
*	c.未初始化的数据段(.bss)
*	d.已初始化的数据段(.data)
*	e.代码段(.text)
*/

// 建议103 浅谈堆和栈
// a.数据结构中的堆和栈
	// 1.栈
	// 先进后出或后进先出
	// 使用两种方式来实现：使用数组的形式来实现栈，这种栈也称为静态栈
	// 使用链表的形式来实现栈，这种栈页称为动态栈
	// 2.堆
	// 堆则是一种经过排序的树形数据结构，常用来实现优先队列
	// 
// b.内存分配中的堆和栈
// 内存分配方式 
//   1.从静态存储区域分配
//   2.在栈上分配
//   3.从堆上分配

// 内存分配中的栈与堆主要存在如下区别
// 1.分配与释放方式
// 2.分配的碎片问题
// 对堆来说，频繁分配和释放不同大小的堆空间势必会造成内存空间的不连续，从而导致程序效率降低。对栈来说不会存在这个问题
// 3.分配的效率
// 栈是机器系统提供的数据结构，计算机 会在底层对栈提供支持
// 堆是由 C/C++ 函数库提供的，堆的分配效率要比栈低很多
// 4.申请的大小限制
// 操作系统是用链表来存储空间内存地址(内存区域不连续),同时链表的遍历方向是由低地址向高地址进行的，堆内存的申请大小受限于计算机系统中有效的虚拟内存
// 栈是一块连续的内存区域，地址的增长方向是向下进行的，向内存地址减小的方向增长
// 栈顶的地址和栈的最大容量一般都是由系统预先规定好的，如果申请的空间超过栈的剩余空间时，将会提示溢出错误。相对于堆，能够从栈中获得的空间相对较小
// 5.存储的内容

// 建议104 避免错误分配内存
// 1.void* malloc(size_t size); 
// 从堆中分配内存空间，内存分配大小为 size.如果内存分配成功，返回首地址，如果失败返回 NULL
// 2.void* calloc(size_t num,size_t size);
// 从队中分配 num 个相邻的内存单元，每个内存单元的大小为 size。如果内存分配成功返回第一个内存单元的首地址，否则返回NULL
// 在使用 calloc 函数分配内存时，会将内存内容初始化0，melloc 则不会
// 3.void* realloc(void* ptr,size_t size);
// 更改堆中已经配置的内存空间，函数试图直接从堆上当前内存段后面的字节中获得更多的内存空间
// 首先判断当前的指针是否由足够的连续存储空间，如果有，则扩大 ptr 指向的地址，并将 ptr返回
// 如果当前内存段后面的空闲字节不够，将先按照 size 指定的大小分配空间(使用堆上第一个能够满足这一要求的内存块),并将原有数据从头到尾拷贝到新分配的内存区域
// 然后释放原来ptr所指内存区域，同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。
// 4.void* alloca(size_t size);
// 从栈中分配内存空间，内存分配大小为 size ,如果成功返回首地址，失败返回NULL
// 无需释放内存空间，自动释放
// 5.void* aligned_alloc(size_t alignment,size_t size);
// 用于边界对齐的动态内存分配函数
// 按照参数 alignment 规定的对齐方式为对象进行动态存储分配 size 个 size_t 类型的存储单元
// 如果成功返回首地址，如果失败返回 NULL
// 相对于 malloc ，aligned_allo 保证返回的地址是能对齐的，同时要求 size参数是 alignment 参数的整数倍

// 建议104-1 对内存分配函数的返回值必须进行检查
// 建议104-2 内存资源的分配与释放应该限定在同一模块或者同一抽象层内进行
// 如果内存的分配和释放在不同的模块或抽象层内，不仅会加大程序员追踪内存块生命周期的负担，而且可能会导致内存泄露，内存双重释放，非法访问已经释放的内存，写入已释放或未分配的内存区域等问题

// 建议104-3 必须对内存分配函数的返回指针进行强制类型转换
// 建议104-4 确保指针指向一块合法的内存
// 仅仅为结构体指针变量分配内存还是不够的，还必须为结构体成员中的所有指针变量分配足够的内存
// 建议104-5 确保为对象分配足够的内存空间
// 建议104-6 禁止指向零长度的内存分配
// 如果在程序中试图调用 malloc/calloc/realloc 等内存分配函数 分配长度为 0 的内存，那么其香味将由具体编译器所定义
// 可能返回 NULL 的指针，又或者是长度为非零的值的，从而导致产生不可预料的结果

// 建议104-7 避免大型的堆栈分配
// C99 标准引入了对变长数组的支持，如果变长数组的长度传入未经任何检查和处理，将很容易被攻击者用来实施攻击 如 Dos攻击
// 建议104-8 避免内存分配成功，但并未初始化  memset
//  错误原因
//	1.没有初始化的观念
//  2.误以为内存的默认初值全部为0，从而导致引用初值错误(如数组)

class Advise102
{
public:
	Advise102() {};
	~Advise102() {};

	void test_01_demo();

	void test_02_demo();

};